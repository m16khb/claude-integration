#!/bin/bash
# Claude Code Status Line Script
# Generated by /setup-statusline command
#
# ì´ ìŠ¤í¬ë¦½íŠ¸ëŠ” Claude Codeì˜ stdinìœ¼ë¡œ ì „ë‹¬ë˜ëŠ” JSON ë°ì´í„°ë¥¼ íŒŒì‹±í•˜ì—¬
# ì»¤ìŠ¤í„°ë§ˆì´ì§•ëœ status lineì„ ì¶œë ¥í•©ë‹ˆë‹¤.
#
# Supported platforms: macOS, Linux, Windows (Git Bash/WSL)
#
# ì„¤ì • íŒŒì¼: ~/.claude/statusline-vars.sh (ì„ íƒì‚¬í•­)
# ì„¤ì • íŒŒì¼ì´ ìžˆìœ¼ë©´ ë¡œë“œí•˜ì—¬ ê¸°ë³¸ê°’ì„ ì˜¤ë²„ë¼ì´ë“œí•©ë‹ˆë‹¤.

# ============================================================================
# LOAD USER CONFIG (ìžˆìœ¼ë©´ ë¡œë“œ, ì—†ìœ¼ë©´ ê¸°ë³¸ê°’ ì‚¬ìš©)
# ============================================================================
STATUSLINE_CONFIG="${HOME}/.claude/statusline-vars.sh"
[[ -f "$STATUSLINE_CONFIG" ]] && source "$STATUSLINE_CONFIG"

# ============================================================================
# DEFAULT CONFIGURATION
# ============================================================================

# Display mode: extended | compact | minimal
MODE="${MODE:-extended}"

# Colors enabled
COLORS_ENABLED="${COLORS_ENABLED:-true}"

# Emoji enabled
EMOJI_ENABLED="${EMOJI_ENABLED:-true}"

# Color palette (ANSI escape codes - 38;5;N format)
COLOR_MODEL="${COLOR_MODEL:-38;5;33}"
COLOR_FEATURE="${COLOR_FEATURE:-38;5;226}"
COLOR_DEVELOP="${COLOR_DEVELOP:-38;5;51}"
COLOR_MAIN="${COLOR_MAIN:-38;5;46}"
COLOR_HOTFIX="${COLOR_HOTFIX:-38;5;196}"
COLOR_RELEASE="${COLOR_RELEASE:-38;5;208}"
COLOR_STAGED="${COLOR_STAGED:-38;5;46}"
COLOR_MODIFIED="${COLOR_MODIFIED:-38;5;208}"
COLOR_UNTRACKED="${COLOR_UNTRACKED:-38;5;196}"
COLOR_COST="${COLOR_COST:-38;5;220}"
COLOR_SEP="${COLOR_SEP:-38;5;240}"

# Emoji settings
EMOJI_MODEL="${EMOJI_MODEL:-ðŸ¤–}"
EMOJI_DIR="${EMOJI_DIR:-ðŸ“‚}"
EMOJI_BRANCH="${EMOJI_BRANCH:-ðŸŒ¿}"
EMOJI_COST="${EMOJI_COST:-ðŸ’°}"

# Display settings
SHOW_MODEL="${SHOW_MODEL:-true}"
SHOW_DIRECTORY="${SHOW_DIRECTORY:-true}"
SHOW_BRANCH="${SHOW_BRANCH:-true}"
SHOW_GIT_STATUS="${SHOW_GIT_STATUS:-true}"
SHOW_COST="${SHOW_COST:-false}"

# Format settings
MAX_DIR_LENGTH="${MAX_DIR_LENGTH:-35}"
MAX_BRANCH_LENGTH="${MAX_BRANCH_LENGTH:-25}"
TRUNCATE_WITH="${TRUNCATE_WITH:-â€¦}"
SEPARATOR="${SEPARATOR:- â”‚ }"

# Cache settings
GIT_CACHE_TTL="${GIT_CACHE_TTL:-5}"

# Cross-platform cache directory
if [[ -n "$TMPDIR" ]]; then
    CACHE_DIR="${CACHE_DIR:-$TMPDIR/claude-statusline-cache}"
elif [[ -n "$TEMP" ]]; then
    CACHE_DIR="${CACHE_DIR:-$TEMP/claude-statusline-cache}"
else
    CACHE_DIR="${CACHE_DIR:-/tmp/claude-statusline-cache}"
fi

# ============================================================================
# CROSS-PLATFORM HELPERS
# ============================================================================

# Cross-platform file modification time (seconds since epoch)
get_file_mtime() {
    local file="$1"
    if [[ "$(uname)" == "Darwin" ]]; then
        # macOS
        stat -f %m "$file" 2>/dev/null
    elif [[ "$(uname)" == "Linux" ]] || [[ "$(uname)" =~ MINGW|MSYS|CYGWIN ]]; then
        # Linux / Git Bash / WSL
        stat -c %Y "$file" 2>/dev/null
    else
        echo 0
    fi
}

# Cross-platform hash for cache key
get_hash() {
    local input="$1"
    if command -v md5sum >/dev/null 2>&1; then
        echo "$input" | md5sum | cut -c1-8
    elif command -v md5 >/dev/null 2>&1; then
        # macOS
        echo "$input" | md5 | cut -c1-8
    else
        # Fallback: simple hash
        echo "$input" | cksum | cut -d' ' -f1
    fi
}

# ============================================================================
# HELPER FUNCTIONS
# ============================================================================

# ANSI color wrapper (printf ì‚¬ìš©ìœ¼ë¡œ subshell ìº¡ì²˜ ì‹œì—ë„ ì´ìŠ¤ì¼€ì´í”„ ìœ ì§€)
color() {
    if [[ "$COLORS_ENABLED" == "true" ]]; then
        printf '\033[%sm%s\033[0m' "$1" "$2"
    else
        printf '%s' "$2"
    fi
}

# Emoji wrapper
emoji() {
    if [[ "$EMOJI_ENABLED" == "true" ]]; then
        printf '%s ' "$1"
    fi
}

# Truncate string with ellipsis
truncate() {
    local str="$1"
    local max="$2"
    if [[ ${#str} -gt $max ]]; then
        echo "${str:0:$((max-1))}${TRUNCATE_WITH}"
    else
        echo "$str"
    fi
}

# Cache wrapper for expensive operations
cached() {
    local key="$1"
    local ttl="$2"
    shift 2
    local cmd="$*"

    mkdir -p "$CACHE_DIR" 2>/dev/null
    local cache_file="$CACHE_DIR/$key"

    # Check if cache is valid
    if [[ -f "$cache_file" ]]; then
        local file_mtime
        file_mtime=$(get_file_mtime "$cache_file")
        local now
        now=$(date +%s)
        local cache_age=$((now - file_mtime))
        if [[ $cache_age -lt $ttl ]]; then
            cat "$cache_file"
            return
        fi
    fi

    # Execute and cache
    local result
    result=$(eval "$cmd" 2>/dev/null)
    echo "$result" > "$cache_file" 2>/dev/null
    echo "$result"
}

# ============================================================================
# DATA EXTRACTION
# ============================================================================

# Read stdin JSON
INPUT=$(cat)

# Extract model name
get_model() {
    local model_id display_name

    # modelì´ ê°ì²´ì¸ ê²½ìš°: {"id": "...", "display_name": "..."}
    # modelì´ ë¬¸ìžì—´ì¸ ê²½ìš°: "claude-opus-4-5-20251101"
    if echo "$INPUT" | jq -e '.model | type == "object"' >/dev/null 2>&1; then
        model_id=$(echo "$INPUT" | jq -r '.model.id // empty' 2>/dev/null)
        display_name=$(echo "$INPUT" | jq -r '.model.display_name // empty' 2>/dev/null)
    else
        model_id=$(echo "$INPUT" | jq -r '.model // empty' 2>/dev/null)
        display_name=""
    fi

    # display_nameì´ ìžˆìœ¼ë©´ ê·¸ëŒ€ë¡œ ì‚¬ìš©
    if [[ -n "$display_name" ]]; then
        echo "$display_name"
        return
    fi

    # model_idì—ì„œ ì½ê¸° ì‰¬ìš´ ì´ë¦„ ì¶”ì¶œ
    case "$model_id" in
        "claude-opus-4-5-20251101")    echo "Opus 4.5" ;;
        "claude-sonnet-4-5-20250929")  echo "Sonnet 4.5" ;;
        "claude-haiku-4-5-20251001")   echo "Haiku 4.5" ;;
        "claude-sonnet-4-20250514")    echo "Sonnet 4" ;;
        "claude-3-5-sonnet"*)          echo "Sonnet 3.5" ;;
        "claude-3-opus"*)              echo "Opus 3" ;;
        "claude-3-haiku"*)             echo "Haiku 3" ;;
        *)                             echo "${model_id:-Claude}" ;;
    esac
}

# Extract workspace directory
get_directory() {
    local dir
    # Claude Code 2.x: workspace.current_dir ë˜ëŠ” cwd ì‚¬ìš©
    dir=$(echo "$INPUT" | jq -r '.workspace.current_dir // .cwd // .workspaceDirs[0] // empty' 2>/dev/null)
    if [[ -n "$dir" ]]; then
        # $HOMEì„ ~ë¡œ ì¶•ì•½
        local short_dir="${dir/#$HOME/~}"
        truncate "$short_dir" "$MAX_DIR_LENGTH"
    fi
}

# Get git branch with caching
get_branch() {
    local cache_key
    cache_key="branch_$(get_hash "$(pwd)")"
    cached "$cache_key" "$GIT_CACHE_TTL" \
        "git branch --show-current 2>/dev/null || git rev-parse --short HEAD 2>/dev/null"
}

# Get branch color based on type
get_branch_color() {
    local branch="$1"
    case "$branch" in
        feature/*)  echo "$COLOR_FEATURE" ;;
        develop)    echo "$COLOR_DEVELOP" ;;
        main|master) echo "$COLOR_MAIN" ;;
        hotfix/*)   echo "$COLOR_HOTFIX" ;;
        release/*)  echo "$COLOR_RELEASE" ;;
        *)          echo "$COLOR_MODEL" ;;
    esac
}

# Get git status counts with caching
get_git_status() {
    local cache_key
    cache_key="status_$(get_hash "$(pwd)")"
    local status
    status=$(cached "$cache_key" "$GIT_CACHE_TTL" \
        "git status --porcelain 2>/dev/null")

    if [[ -z "$status" ]]; then
        return
    fi

    local staged=0 modified=0 untracked=0

    while IFS= read -r line; do
        local x="${line:0:1}"
        local y="${line:1:1}"

        # Staged changes (index)
        [[ "$x" =~ [MADRC] ]] && ((staged++))
        # Modified in worktree
        [[ "$y" == "M" ]] && ((modified++))
        # Untracked
        [[ "$x" == "?" ]] && ((untracked++))
    done <<< "$status"

    local result=""
    [[ $staged -gt 0 ]] && result+="$(color "$COLOR_STAGED" "+$staged")"
    [[ $modified -gt 0 ]] && result+="$(color "$COLOR_MODIFIED" "!$modified")"
    [[ $untracked -gt 0 ]] && result+="$(color "$COLOR_UNTRACKED" "?$untracked")"

    echo "$result"
}

# Get cost info
get_cost() {
    local cost
    # Claude Code 2.x: cost.total_cost_usd ì‚¬ìš©
    cost=$(echo "$INPUT" | jq -r '.cost.total_cost_usd // .costs.total // empty' 2>/dev/null)
    if [[ -n "$cost" ]] && [[ "$cost" != "0" ]]; then
        printf "\$%.2f" "$cost"
    fi
}

# ============================================================================
# OUTPUT GENERATION
# ============================================================================

build_statusline() {
    local parts=()

    # Model
    if [[ "$SHOW_MODEL" == "true" ]]; then
        local model
        model=$(get_model)
        if [[ -n "$model" ]]; then
            local model_display
            model_display="$(emoji "$EMOJI_MODEL")$(color "$COLOR_MODEL" "$model")"
            parts+=("$model_display")
        fi
    fi

    # Directory
    if [[ "$SHOW_DIRECTORY" == "true" ]]; then
        local dir
        dir=$(get_directory)
        if [[ -n "$dir" ]]; then
            local dir_display
            dir_display="$(emoji "$EMOJI_DIR")$dir"
            parts+=("$dir_display")
        fi
    fi

    # Branch
    if [[ "$SHOW_BRANCH" == "true" ]]; then
        local branch
        branch=$(get_branch)
        if [[ -n "$branch" ]]; then
            local branch_color
            branch_color=$(get_branch_color "$branch")
            local display_branch
            display_branch=$(truncate "$branch" "$MAX_BRANCH_LENGTH")
            local branch_display
            branch_display="$(emoji "$EMOJI_BRANCH")$(color "$branch_color" "$display_branch")"
            parts+=("$branch_display")
        fi
    fi

    # Git status
    if [[ "$SHOW_GIT_STATUS" == "true" ]]; then
        local git_status
        git_status=$(get_git_status)
        [[ -n "$git_status" ]] && parts+=("$git_status")
    fi

    # Cost (optional)
    if [[ "$SHOW_COST" == "true" ]]; then
        local cost
        cost=$(get_cost)
        if [[ -n "$cost" ]]; then
            local cost_display
            cost_display="$(emoji "$EMOJI_COST")$(color "$COLOR_COST" "$cost")"
            parts+=("$cost_display")
        fi
    fi

    # Join with separator
    local sep
    sep=$(color "$COLOR_SEP" "$SEPARATOR")

    local output=""
    local first=true
    for part in "${parts[@]}"; do
        if [[ "$first" == "true" ]]; then
            output="$part"
            first=false
        else
            output+="${sep}${part}"
        fi
    done

    printf '%s' "$output"
}

# ============================================================================
# MAIN
# ============================================================================

# Suppress all stderr for clean output
exec 2>/dev/null

# Build and output status line
build_statusline || printf ''
