#!/bin/bash
# Claude Code Status Line Script
# Auto-generated by /setup-statusline command
#
# 이 스크립트는 Claude Code의 stdin으로 전달되는 JSON 데이터를 파싱하여
# 커스터마이징된 status line을 출력합니다.
#
# Input JSON format:
# {
#   "model": "claude-opus-4-5-20251101",
#   "workspaceDirs": ["/path/to/project"],
#   "version": "1.0.0",
#   "costs": { "total": 0.05 }
# }

# ============================================================================
# CONFIGURATION (setup-statusline 커맨드가 자동 생성)
# ============================================================================

# Display mode: extended | compact | minimal
MODE="${STATUSLINE_MODE:-extended}"

# Colors enabled
COLORS_ENABLED="${STATUSLINE_COLORS:-true}"

# Color palette (ANSI escape codes)
COLOR_MODEL="${COLOR_MODEL:-38;5;33}"
COLOR_FEATURE="${COLOR_FEATURE:-38;5;226}"
COLOR_DEVELOP="${COLOR_DEVELOP:-38;5;51}"
COLOR_MAIN="${COLOR_MAIN:-38;5;46}"
COLOR_HOTFIX="${COLOR_HOTFIX:-38;5;196}"
COLOR_RELEASE="${COLOR_RELEASE:-38;5;208}"
COLOR_STAGED="${COLOR_STAGED:-38;5;46}"
COLOR_MODIFIED="${COLOR_MODIFIED:-38;5;208}"
COLOR_UNTRACKED="${COLOR_UNTRACKED:-38;5;196}"
COLOR_DURATION="${COLOR_DURATION:-38;5;245}"
COLOR_COST="${COLOR_COST:-38;5;220}"
COLOR_SEP="${COLOR_SEP:-38;5;240}"
COLOR_RESET="\e[0m"

# Display settings
SHOW_MODEL="${SHOW_MODEL:-true}"
SHOW_DURATION="${SHOW_DURATION:-true}"
SHOW_DIRECTORY="${SHOW_DIRECTORY:-true}"
SHOW_BRANCH="${SHOW_BRANCH:-true}"
SHOW_GIT_STATUS="${SHOW_GIT_STATUS:-true}"
SHOW_COST="${SHOW_COST:-false}"

# Format settings
MAX_DIR_LENGTH="${MAX_DIR_LENGTH:-20}"
MAX_BRANCH_LENGTH="${MAX_BRANCH_LENGTH:-25}"
TRUNCATE_WITH="${TRUNCATE_WITH:-…}"
SEPARATOR="${SEPARATOR:- │ }"

# Cache settings
GIT_CACHE_TTL="${GIT_CACHE_TTL:-5}"
CACHE_DIR="${CACHE_DIR:-/tmp/claude-statusline-cache}"

# ============================================================================
# HELPER FUNCTIONS
# ============================================================================

# ANSI color wrapper
color() {
    if [[ "$COLORS_ENABLED" == "true" ]]; then
        echo -e "\e[${1}m${2}${COLOR_RESET}"
    else
        echo -n "$2"
    fi
}

# Truncate string with ellipsis
truncate() {
    local str="$1"
    local max="$2"
    if [[ ${#str} -gt $max ]]; then
        echo "${str:0:$((max-1))}${TRUNCATE_WITH}"
    else
        echo "$str"
    fi
}

# Cache wrapper for expensive operations
cached() {
    local key="$1"
    local ttl="$2"
    shift 2
    local cmd="$*"

    mkdir -p "$CACHE_DIR"
    local cache_file="$CACHE_DIR/$key"

    # Check if cache is valid
    if [[ -f "$cache_file" ]]; then
        local cache_age=$(($(date +%s) - $(stat -f %m "$cache_file" 2>/dev/null || stat -c %Y "$cache_file" 2>/dev/null || echo 0)))
        if [[ $cache_age -lt $ttl ]]; then
            cat "$cache_file"
            return
        fi
    fi

    # Execute and cache
    local result
    result=$(eval "$cmd" 2>/dev/null)
    echo "$result" > "$cache_file"
    echo "$result"
}

# ============================================================================
# DATA EXTRACTION
# ============================================================================

# Read stdin JSON
INPUT=$(cat)

# Extract model name
get_model() {
    local model
    model=$(echo "$INPUT" | jq -r '.model // empty' 2>/dev/null)

    # Apply aliases
    case "$model" in
        "claude-opus-4-5-20251101")    echo "O 4.5" ;;
        "claude-sonnet-4-5-20250929")  echo "S 4.5" ;;
        "claude-haiku-4-5-20251001")   echo "H 4.5" ;;
        "claude-sonnet-4-20250514")    echo "S 4" ;;
        "claude-3-5-sonnet"*)          echo "S 3.5" ;;
        "claude-3-opus"*)              echo "O 3" ;;
        "claude-3-haiku"*)             echo "H 3" ;;
        *)                             echo "${model:-Claude}" ;;
    esac
}

# Extract workspace directory
get_directory() {
    local dir
    dir=$(echo "$INPUT" | jq -r '.workspaceDirs[0] // empty' 2>/dev/null)
    if [[ -n "$dir" ]]; then
        truncate "$(basename "$dir")" "$MAX_DIR_LENGTH"
    fi
}

# Get git branch with caching
get_branch() {
    cached "branch_$(pwd | md5sum | cut -c1-8 2>/dev/null || echo 'default')" "$GIT_CACHE_TTL" \
        "git branch --show-current 2>/dev/null || git rev-parse --short HEAD 2>/dev/null"
}

# Get branch color based on type
get_branch_color() {
    local branch="$1"
    case "$branch" in
        feature/*)  echo "$COLOR_FEATURE" ;;
        develop)    echo "$COLOR_DEVELOP" ;;
        main|master) echo "$COLOR_MAIN" ;;
        hotfix/*)   echo "$COLOR_HOTFIX" ;;
        release/*)  echo "$COLOR_RELEASE" ;;
        *)          echo "$COLOR_MODEL" ;;
    esac
}

# Get git status counts with caching
get_git_status() {
    local status
    status=$(cached "status_$(pwd | md5sum | cut -c1-8 2>/dev/null || echo 'default')" "$GIT_CACHE_TTL" \
        "git status --porcelain 2>/dev/null")

    if [[ -z "$status" ]]; then
        return
    fi

    local staged=0 modified=0 untracked=0

    while IFS= read -r line; do
        local x="${line:0:1}"
        local y="${line:1:1}"

        # Staged changes (index)
        [[ "$x" =~ [MADRC] ]] && ((staged++))
        # Modified in worktree
        [[ "$y" == "M" ]] && ((modified++))
        # Untracked
        [[ "$x" == "?" ]] && ((untracked++))
    done <<< "$status"

    local result=""
    [[ $staged -gt 0 ]] && result+="$(color "$COLOR_STAGED" "+$staged")"
    [[ $modified -gt 0 ]] && result+="$(color "$COLOR_MODIFIED" "~$modified")"
    [[ $untracked -gt 0 ]] && result+="$(color "$COLOR_UNTRACKED" "?$untracked")"

    echo "$result"
}

# Get cost info
get_cost() {
    local cost
    cost=$(echo "$INPUT" | jq -r '.costs.total // empty' 2>/dev/null)
    if [[ -n "$cost" ]] && [[ "$cost" != "0" ]]; then
        printf "\$%.2f" "$cost"
    fi
}

# ============================================================================
# OUTPUT GENERATION
# ============================================================================

build_statusline() {
    local parts=()

    # Model
    if [[ "$SHOW_MODEL" == "true" ]]; then
        local model
        model=$(get_model)
        [[ -n "$model" ]] && parts+=("$(color "$COLOR_MODEL" "$model")")
    fi

    # Directory
    if [[ "$SHOW_DIRECTORY" == "true" ]]; then
        local dir
        dir=$(get_directory)
        [[ -n "$dir" ]] && parts+=("$dir")
    fi

    # Branch
    if [[ "$SHOW_BRANCH" == "true" ]]; then
        local branch
        branch=$(get_branch)
        if [[ -n "$branch" ]]; then
            local branch_color
            branch_color=$(get_branch_color "$branch")
            local display_branch
            display_branch=$(truncate "$branch" "$MAX_BRANCH_LENGTH")
            parts+=("$(color "$branch_color" "$display_branch")")
        fi
    fi

    # Git status
    if [[ "$SHOW_GIT_STATUS" == "true" ]]; then
        local git_status
        git_status=$(get_git_status)
        [[ -n "$git_status" ]] && parts+=("$git_status")
    fi

    # Cost (optional)
    if [[ "$SHOW_COST" == "true" ]]; then
        local cost
        cost=$(get_cost)
        [[ -n "$cost" ]] && parts+=("$(color "$COLOR_COST" "$cost")")
    fi

    # Join with separator
    local sep
    sep=$(color "$COLOR_SEP" "$SEPARATOR")

    local output=""
    local first=true
    for part in "${parts[@]}"; do
        if [[ "$first" == "true" ]]; then
            output="$part"
            first=false
        else
            output+="${sep}${part}"
        fi
    done

    echo -e "$output"
}

# ============================================================================
# MAIN
# ============================================================================

# Error handling
set -o pipefail

# Build and output status line
if result=$(build_statusline 2>/dev/null); then
    echo "$result"
else
    # Graceful degradation - output nothing on error
    echo ""
fi
